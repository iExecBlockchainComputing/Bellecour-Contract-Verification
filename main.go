package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"net/textproto"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"
)

type AutoGeneratedV2 struct {
	IsVerified bool `json:"is_verified"`
}

type VerifySmartContract struct {
	Items        []string `json:"items"`
	NextPagePath string   `json:"next_page_path"`
}

type BeforeV2 struct {
	Message string `json:"message"`
	Result  []struct {
		ABI               string `json:"ABI"`
		AdditionalSources []struct {
			Filename   string `json:"Filename"`
			SourceCode string `json:"SourceCode"`
		} `json:"AdditionalSources"`
		CompilerSettings struct {
			EvmVersion string    `json:"evmVersion"`
			Libraries  Libraries `json:"libraries"`
			Metadata   struct {
				UseLiteralContent bool `json:"useLiteralContent"`
			} `json:"metadata"`
			Optimizer struct {
				Details struct {
					Yul        bool `json:"yul"`
					YulDetails struct {
						OptimizerSteps string `json:"optimizerSteps"`
					} `json:"yulDetails"`
				} `json:"details"`
				Enabled bool `json:"enabled"`
				Runs    int  `json:"runs"`
			} `json:"optimizer"`
			OutputSelection struct {
				Star struct {
					Empty []string `json:""`
					Star  []string `json:"*"`
				} `json:"*"`
			} `json:"outputSelection"`
			ViaIR bool `json:"viaIR"`
		} `json:"CompilerSettings"`
		CompilerVersion   string `json:"CompilerVersion"`
		ContractName      string `json:"ContractName"`
		EVMVersion        string `json:"EVMVersion"`
		ExternalLibraries []struct {
			AddressHash string `json:"address_hash"`
			Name        string `json:"name"`
		} `json:"ExternalLibraries"`
		FileName         string `json:"FileName"`
		IsProxy          string `json:"IsProxy"`
		OptimizationRuns int    `json:"OptimizationRuns"`
		OptimizationUsed string `json:"OptimizationUsed"`
		SourceCode       string `json:"SourceCode"`
		Address          string `json:"Address"`
	} `json:"result"`
	Status string `json:"status"`
}

type ContractUltimate struct {
	Language string           `json:"language"`
	Sources  Sources          `json:"sources"`
	Settings UltimateSettings `json:"settings"`
}
type Sources map[string]Source
type Source struct {
	Content string `json:"content"`
}

type UltimateSettings struct {
	EvmVersion string `json:"evmVersion"`
	Metadata   struct {
		UseLiteralContent bool   `json:"useLiteralContent"`
		BytecodeHash      string `json:"bytecodeHash"`
	} `json:"metadata"`
	Optimizer struct {
		Enabled bool    `json:"enabled"`
		Runs    int     `json:"runs"`
		Details Details `json:"details"`
	} `json:"optimizer"`
	OutputSelection OutputSel `json:"outputSelection`
	Libraries       Libraries `json:"libraries"`
	ViaIR           bool      `json:"viaIR"`
}

type OutputSel map[string]map[string][]string

type Libraries struct {
	ContractsLibsIexecLibOrdersV5Sol struct {
		IexecLibOrdersV5 string `json:"IexecLibOrders_v5"`
	} `json:"contracts/libs/IexecLibOrders_v5.sol"`
}

type Library struct {
	Content string `json:"content"`
}

type Details struct {
	ConstantOptimizer bool       `json:"constantOptimizer"`
	Cse               bool       `json:"cse"`
	Deduplicate       bool       `json:"deduplicate"`
	Inliner           bool       `json:"inliner"`
	JumpdestRemover   bool       `json:"jumpdestRemover"`
	OrderLiterals     bool       `json:"orderLiterals"`
	Peephole          bool       `json:"peephole"`
	Yul               bool       `json:"yul"`
	YulDetails        YulDetails `json:"yulDetails"`
}
type YulDetails struct {
	OptimizerSteps  string `json:"optimizerSteps"`
	StackAllocation bool   `json:"stackAllocation"`
}

// ///////////////////////QUERRY VERIFIED SMART CONTRACT ON BLOKSCOUT V5 AND VERIFY ON V6 ///////////////////////////////////////
func QuerySmartContractVerify(smartContractAddress string) {

	client := &http.Client{}

	url := "https://blockscout-v5.bellecour.iex.ec/api?module=contract&action=getsourcecode&address="

	fmt.Println(url + smartContractAddress)

	req, err := http.NewRequest("GET", fmt.Sprintf("%s%s", url, smartContractAddress), nil)
	if err != nil {
		panic(err)
	}
	// fmt.Fprintf(req.URL)

	// Execute the request and get the response.
	resp, err := client.Do(req)

	if err != nil {
		// Handle the error.
		panic(err)

	}
	defer resp.Body.Close()

	// var resultPage AutoGenerated
	var resultPage BeforeV2
	if err := json.NewDecoder(resp.Body).Decode(&resultPage); err != nil {
		// Handle the error.
		panic(err)
	}
	filename := "before.json"
	file, err := os.Create(filename)
	if err != nil {
		panic(err)

	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ") // Set indentation for pretty-printing
	err = encoder.Encode(resultPage)
	if err != nil {
		panic(err)
	}

	fmt.Println("resultPage saved as", filename)

	verifiedSmartContractNewBlockscout(smartContractAddress, resultPage)
}
func verifiedSmartContractNewBlockscout(smartContractAddress string, nonStandardJSON BeforeV2) {

	url := "https://blockscout.bellecour.iex.ec/api/v2/smart-contracts/"
	verification := "/verification/via/standard-input"

	// Create the multipart/form-data request
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	fmt.Println("address_hash", nonStandardJSON.Result[0].Address)

	err := writer.WriteField("address_hash", nonStandardJSON.Result[0].Address)
	if err != nil {
		log.Fatalf("Failed to close writer: %v", err)
	}

	err = writer.WriteField("compiler_version", nonStandardJSON.Result[0].CompilerVersion)
	if err != nil {
		log.Fatalf("Failed to close writer: %v", err)
	}
	fmt.Println("compiler_version", nonStandardJSON.Result[0].CompilerVersion)

	err = writer.WriteField("constructor_args", "")
	if err != nil {
		log.Fatalf("Failed to close writer: %v", err)
	}
	err = writer.WriteField("autodetect_constructor_args", "false")
	if err != nil {
		log.Fatalf("Failed to close writer: %v", err)
	}

	err = writer.WriteField("contract_name", nonStandardJSON.Result[0].ContractName)
	if err != nil {
		log.Fatalf("Failed to close writer: %v", err)
	}
	fmt.Println("contract_name", nonStandardJSON.Result[0].ContractName)

	// transformIntoStandardJSON(nonStandardJSON)
	var jsonValue []byte
	jsonValue, err = json.Marshal(transformIntoStandardJSON(nonStandardJSON))
	if err != nil {
		fmt.Println(err)
		return
	}

	part, err := createFormFileWithContentType(writer, "files[0]", "name.json", "application/json")
	// // part, err := writer.CreateFormFile("files[0]", "name.json")
	if err != nil {
		log.Fatalf("Failed to close writer: %v", err)
	}
	_, err = part.Write(jsonValue)
	if err != nil {
		log.Fatalf("Failed to close writer: %v", err)
	}

	err = writer.Close()
	if err != nil {
		log.Fatalf("Failed to close writer: %v", err)
	}

	// Create the HTTP request

	req, err := http.NewRequest("POST", fmt.Sprintf("%s%s%s", url, smartContractAddress, verification), body)
	if err != nil {
		panic(err)
	}

	// Set the appropriate headers
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Execute the HTTP request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("Failed to execute HTTP request: %v", err)
	}
	defer resp.Body.Close()

	// Read the response
	respBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Failed to read response body: %v", err)
	}

	// Print the response
	if resp.StatusCode == 200 {
		fmt.Printf("Check : https://blockscout.bellecour.iex.ec/api/v2/smart-contracts/%s\n", smartContractAddress)
		fmt.Println("Response Status:", resp.Status)
		fmt.Println("Response Body:", string(respBody))
	} else {
		fmt.Println("========================================================================", smartContractAddress)
		fmt.Println("Response Status:", resp.Status)
		fmt.Println("Response Body:", string(respBody))
	}
}
func transformIntoStandardJSON(nonStandardJSON BeforeV2) ContractUltimate {
	var contract ContractUltimate
	contract.Language = "Solidity"
	contract.Settings.EvmVersion = nonStandardJSON.Result[0].EVMVersion
	contract.Settings.Metadata.UseLiteralContent = nonStandardJSON.Result[0].CompilerSettings.Metadata.UseLiteralContent
	contract.Settings.Metadata.BytecodeHash = "ipfs"
	boolVal, _ := strconv.ParseBool(nonStandardJSON.Result[0].OptimizationUsed)
	contract.Settings.Optimizer.Enabled = boolVal
	contract.Settings.Optimizer.Runs = nonStandardJSON.Result[0].OptimizationRuns
	contract.Settings.ViaIR = nonStandardJSON.Result[0].CompilerSettings.ViaIR
	var yulDetails = YulDetails{
		OptimizerSteps:  "u:fDnTOc",
		StackAllocation: true,
	}
	var optimizerDetails Details
	optimizerDetails = Details{
		Peephole:          true,
		JumpdestRemover:   true,
		OrderLiterals:     true,
		Deduplicate:       true,
		Cse:               true,
		ConstantOptimizer: true,
		Inliner:           true,
	}
	optimizerDetails.Yul = true
	optimizerDetails.YulDetails = yulDetails
	contract.Settings.Optimizer.Details = optimizerDetails

	// contract.Settings.OutputSelection = nonStandardJSON.Result[0].CompilerSettings.OutputSelection
	// contract.Settings.OutputSelection.Star.Star = []string{"*"}
	// contract.Settings.OutputSelection.Star.Empty = []string{"*"}
	outputSelection := OutputSel{
		"*": {
			"":  []string{"*"},
			"*": []string{"*"},
		},
	}
	contract.Settings.OutputSelection = outputSelection
	contract.Settings.Libraries = nonStandardJSON.Result[0].CompilerSettings.Libraries

	contract.Sources = make(map[string]Source)
	contract.Sources[nonStandardJSON.Result[0].FileName] = Source{Content: nonStandardJSON.Result[0].SourceCode}
	for _, source := range nonStandardJSON.Result[0].AdditionalSources {
		contract.Sources[source.Filename] = Source{Content: source.SourceCode}
	}
	filename := "contract.json"
	file, err := os.Create(filename)
	if err != nil {
		return contract
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ") // Set indentation for pretty-printing
	err = encoder.Encode(contract)
	if err != nil {
		return contract
	}

	// fmt.Println("Contract saved as", filename)
	return contract
}

// ///////////////////////QUERRY VERIFIED SMART CONTRACT ADDRESSES ON BLOKSCOUT V5 ///////////////////////////////////////
func GetAllSmartContractsVerifedAddress() []string {
	var smartContractAddressResponse []string

	// Start with the initial URL
	first := "https://blockscout-bellecour.iex.ec"
	verified := "/verified-contracts?"
	end := "type=JSON"
	url := first + verified + end

	for url != "" {
		client := &http.Client{}
		// fmt.Println(url)

		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			panic(err)
		}

		// Execute the request and get the response.
		resp, err := client.Do(req)
		if err != nil {
			panic(err)
		}
		defer resp.Body.Close()

		var resultPage VerifySmartContract
		if err := json.NewDecoder(resp.Body).Decode(&resultPage); err != nil {
			panic(err)
		}

		// fmt.Println(resultPage.NextPagePath)

		// Extract contract addresses from the current page
		for _, v := range resultPage.Items {
			smartContractAddressResponse = append(smartContractAddressResponse, extractContractAddress(v))
		}
		if resultPage.NextPagePath == "" {
			url = ""
		} else {

			// Update the URL with the next page path
			url = first + resultPage.NextPagePath + "&" + end
		}
	}

	return smartContractAddressResponse
}
func extractContractAddress(itemsStringValue string) string {
	re := regexp.MustCompile(`data-address-hash="(0x[0-9a-fA-F]{40})"`)
	match := re.FindStringSubmatch(itemsStringValue)
	if len(match) > 1 {
		contractAddress := match[1]
		return contractAddress
	} else {
		return ""
	}
}
func verifyIfSmartContractIsVerifed(smartContractAddress string) bool {
	client := &http.Client{}

	url := "https://blockscout.bellecour.iex.ec/api/v2/smart-contracts/"

	// fmt.Println(url + smartContractAddress)

	req, err := http.NewRequest("GET", fmt.Sprintf("%s%s", url, smartContractAddress), nil)
	if err != nil {
		panic(err)
	}
	// fmt.Fprintf(req.URL)

	// Execute the request and get the response.
	resp, err := client.Do(req)

	if err != nil {
		// Handle the error.
		panic(err)

	}
	defer resp.Body.Close()

	var resultPage AutoGeneratedV2
	if err := json.NewDecoder(resp.Body).Decode(&resultPage); err != nil {
		// Handle the error.
		panic(err)
	}
	if resultPage.IsVerified == true {
		fmt.Println(resultPage.IsVerified)
		return true
	} else {
		fmt.Println(resultPage.IsVerified)
		return false
	}
}

// /////////////////////// HELPER FUNCTIONS ///////////////////////////////////////
func createFormFileWithContentType(w *multipart.Writer, fieldname, filename, contentType string) (io.Writer, error) {
	h := make(textproto.MIMEHeader)
	h.Set("Content-Disposition",
		fmt.Sprintf(`form-data; name="%s"; filename="%s"`,
			escapeQuotes(fieldname), escapeQuotes(filename)))
	h.Set("Content-Type", contentType)
	return w.CreatePart(h)
}

var quoteEscaper = strings.NewReplacer("\\", "\\\\", `"`, "\\\"")

func escapeQuotes(s string) string {
	return quoteEscaper.Replace(s)
}

func main() {
	// listOfContractAddresses := GetAllSmartContractsVerifedAddress()
	// listOfContractAddresses := []string{
	// 	"0xe39E2aDd731b449bAB187f34f0dd39c4AfCd4f97",
	// 	"0xf2F8eBD6DF066f93dc012CC94FBfA4592727a910",
	// }
	// fmt.Printf("%v\n", len(listOfContractAddresses))
	// for _, smartContractAddress := range listOfContractAddresses {
	// 	if !verifyIfSmartContractIsVerifed(smartContractAddress) {
	// 		fmt.Printf("smart contract not verified %v\n", smartContractAddress)
	// 		// QuerySmartContractVerify(smartContractAddress)
	// 		// time.Sleep(10 * time.Second)
	// 	} else {
	// 	}
	// }
	// 0x7eCf076343FBe296Da2D39f20B2a01AaBB68CC27
	// 0x1eE1cceF893DF6c4D3FC4eCaF315F09183f3048c
	QuerySmartContractVerify("0x1eE1cceF893DF6c4D3FC4eCaF315F09183f3048c")
}
